{
  "hash": "ef100f78a7c300a524002443d8400dcc",
  "result": {
    "engine": "knitr",
    "markdown": "# Tworzenie pakietów R (3)\n\n## Dane w pakietach R\n\nPakiety R mogą również zawierać dane. \nZazwyczaj takie dane służą do trzech celów: (1) do przechowywania danych, które są używane wewnątrz pakietu, (2) do użycia w przykładach i innych formach dokumentacji, oraz (3) do testowania funkcji.\n\nIstnieje kilka mechanizmów do przechowywania danych w pakietach R:\n\n1. Dane w postaci binarnej w folderze `data/`\n2. Dane w postaci oryginalnej w podfolderze folderu `inst/`\n3. Dane w postaci binarnej w pliku `R/sysdata.rda`\n4. Dane stworzone wewnątrz kodu R, np. kodu przykładu czy kodu testu\n\nKażdy z nich ma swoje wady i zalety, szczególnie widoczne w przypadku wykorzystywania danych przestrzennych.\n\n::: {.callout-note}\nCRAN z reguły nie pozwala na umieszczanie w pakietach danych o rozmiarze większym niż ok. 5 MB.\nW związku z tym, jeżeli dane są większe niż 5 MB, to należy je umieścić w innym miejscu, np. na GitHubie, a wewnątrz pakietu umieścić tylko kod do ich pobrania.\n:::\n\n### Dane w postaci binarnej w folderze `data/`\n\nNiemal każdy obiekt R można zapisać wewnątrz pakietu jako plik binarny (`.rda`) w folderze `data/`.\nNajprościej dodać taki obiekt używając funkcji `usethis::use_data()`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoj_df = data.frame(x = 1:10, y = 11:20)\nusethis::use_data(moj_df, overwrite = TRUE)\n```\n:::\n\n\n\n\n\n\nPowyższy kod stworzy plik `data/moj_df.rda` zawierający obiekt `moj_df`.\nTeraz ten obiekt jest dostępny wewnątrz pakietu i można go użyć wewnątrz funkcji, przykładów, czy testów jednostkowych.\n\n::: {.callout-note}\nJeden z możliwych elementów opisu pakietu w pliku `DESCRIPTION` to `LazyData`.\nPrzyjmuje on wartość `true` lub `false` i określa czy dane w folderze `data/` są ładowane do pamięci podczas ładowania pakietu.\nW przypadku `LazyData: true` dane są ładowane do środowiska pracy podczas ładowania pakietu i są od razu dostępne.\nW przypadku `LazyData: false` dane są ładowane do środowiska pracy dopiero w momencie ich wywołania, np. poprzez funkcję `data()`.\n:::\n\nWarto kod R użyty do stworzenia takich danych umieścić w folderze `data-raw/`.\nA sam folder `data-raw/` należy dodać do pliku `.Rbuildignore`.^[Można też użyć funkcji `usethis::use_data_raw()`.]\nDzięki temu możliwe będzie odtworzenie budowy takich danych w przyszłości, jeżeli zajdzie taka konieczność.\n\nDane załączone w ten sposób muszą być udokumentowane.\nTaka dokumentacja to plik o rozszerzeniu `.R` w folderze `R/` zawierający funkcję `roxygen2` z odpowiednimi tagami.\nPrzykładowo, dla obiektu `moj_df` można stworzyć plik `R/moj_df.R` zawierający:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Example data\n#' \n#' Example data created manually for the purpose of this package.\n#' \n#' @format ## `moj_df`\n#' A data frame with 10 observations on 2 variables.\n#' \\describe{\n#'  \\item{x}{numeric vector}\n#'  \\item{y}{numeric vector}\n#' }\n#' @source Manually created.\n\"moj_df\"\n```\n:::\n\n\n\n\n\n\n### Dane w postaci oryginalnej w podfolderze folderu `inst/`\n\nWewnątrz podfolderu folderu `inst/` (np. `inst/data/`) można umieścić dowolne pliki, które będą dostępne po zainstalowaniu pakietu.\nDotyczy to, np., plików `.csv` ale także różnorodnych formatów GIS, `.gpkg` czy `.tif`.\n\nPo instalacji pakietu, folder `inst/` nie jest dostępny, a jego zawartość znajduje się bezpośrednio w folderze instalacyjnym pakietu.\nDostępne foldery można sprawdzić używając funkcji `system.file()` oraz `dir()`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsystem.file(package = \"spData\") |> dir()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"data\"        \"DESCRIPTION\" \"help\"        \"html\"        \"INDEX\"      \n [6] \"Meta\"        \"misc\"        \"NAMESPACE\"   \"R\"           \"raster\"     \n[11] \"README\"      \"shapes\"      \"weights\"    \n```\n\n\n:::\n:::\n\n\n\n\n\n\nW tym przypadku mamy kilka folderów z danymi: `data/`, `misc/`, `raster/`, `shapes/`, oraz `weights/`.\nSprawdzenie zawartości danego folderu jest możliwe poprzez podanie jego nazwy jako argumentu funkcji `system.file()`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsystem.file(\"raster\", package = \"spData\") |> dir()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"elev.tif\"          \"grain.tif\"         \"grain.tif.aux.xml\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNastępnie można użyć funkcji `system.file()` do określenia ścieżki do wybranego pliku na danym komputerze.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsystem.file(\"raster/elev.tif\", package = \"spData\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/home/jn/R/x86_64-redhat-linux-gnu-library/4.4/spData/raster/elev.tif\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nZnajomość tej ścieżki pozwala na wczytanie pliku do R.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nplot(elev)\n```\n\n::: {.cell-output-display}\n![](pakiety3_files/figure-pdf/unnamed-chunk-6-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n\n\n::: {.callout-note}\nPrzechowywanie danych w postaci binarnej jest szczególnie dobrym rozwiązaniem w przypadku, gdy przechowywane obiekty mają jedną z klas wbudowanych w język R (np. ramka danych czy macierz).\n\nPodejście oparte na przechowywaniu danych w postaci oryginalnej jest szczególnie dobre w kontekście danych przestrzennych:\n\n1. Interpretacja elementów obiektów przestrzennych (np. układu współrzędnych przez bibliotekę PROJ) zmienia się w czasie. \nW związku z tym, dane przestrzenne zapisane w postaci binarnej mogą być niepoprawne w przyszłości.\n2. Główna klasa obiektów w pakiecie **terra** nie przechowuje wartości, ale tylko wskaźnik (ang. *pointer*) C++ do pliku na dysku.\nW związku z tym, obiekty **terra** zapisane w postaci binarnej mogą nie być poprawie załadowane do pamięci podczas ładowania pakietu.\n3. Dane są dostępne w oryginalnym formacie, co umożliwia ich użycie poza R.\n:::\n\n### Dane w postaci binarnej w pliku `R/sysdata.rda`\n\nWewnątrz pakietu można umieścić dane w postaci binarnej w pliku `R/sysdata.rda`.\nTakie dane są dostępne tylko wewnątrz pakietu i nie są ładowane do środowiska pracy.\nNie wymagają też dodatkowej dokumentacji.\n\nDo stworzenia takiego pliku użyć funkcji `usethis::use_data()` z argumentem `internal = TRUE`.\nNależy tylko pamiętać, że plik `R/sysdata.rda` może zawierać więcej niż jeden obiekt i wówczas te obiekty należy zapisać w poniższy sposób.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoj_df = data.frame(x = 1:10, y = 11:20)\nmoj_df2 = data.frame(x = 1:10, y = 11:20)\nusethis::use_data(moj_df, moj_df2, internal = TRUE)\n```\n:::\n\n\n\n\n\n\n### Dane stworzone wewnątrz kodu R\n\nMałe dane można stworzyć bezpośrednio wewnątrz kodu R.\nMoże to mieć miejsce przed przykładem użycia danej funkcji czy też przed testem jednostkowym.\n\n::: {.callout-note appearance=\"simple\"}\n\n## ZADANIA\n\n1. Stwórz nowy obiekt zawierający dane przykładowe, które będzie można użyć w przykładach twojego pakietu.\n2. Zapisz kod tworzący ten obiekt do folderu `data-raw/`.\n3. Dodaj ten obiekt do folderu `data/` używając funkcji `usethis::use_data()`.\n4. Dodaj dokumentację dla tego obiektu do folderu `R/`.\n5. Zapisz ten obiekt do zewnętrznego formatu (np. `.csv`) i umieść go wewnątrz podfolderu folderu `inst/`.\n6. Użyj zarówno wewnętrznych jak i zewnętrznych danych wewnątrz przykładu jakieś funkcji z twojego pakietu.\n7. Uruchom `devtools::document()` a następnie `devtools::check()` i sprawdź czy wszystko działa poprawnie.\n\n:::\n\n## Testy jednostkowe {#sec-testy-jednostkowe}\n\nTesty jednostkowe (ang. *unit tests*) to sposób sprawdzania czy stworzona przez nas funkcja działa w sposób jaki oczekujemy.\nTworzenie takich testów wymusza także myślenie na temat odpowiedniego działania funkcji i jej API.\nTesty jednostkowe są najczęściej stosowane w przypadku budowania pakietów, gdzie możliwe jest automatyczne sprawdzenie wielu testów na raz.\nPrzykładowo, napisaliśmy nową funkcję, która wykonuje złożone operacje i, po wielu sprawdzeniach, wiemy, że daje poprawne wyniki.\nPo kilku miesiącach wpadliśmy na pomysł jak zwiększyć wydajność naszej funkcji. \nW tym momencie wystarczy już tylko stworzyć nową implementację i użyć wcześniej zbudowanych testów.\nDadzą one informację, czy efekt działania jest taki jaki oczekujemy, a w przeciwnym razie wskażą gdzie pojawił się błąd. \nIstnieje też dodatkowa reguła - jeżeli znajdziesz błąd w kodzie od razu napisz test jednostkowy.\n\nZobaczmy jak działają testy jednostkowe na przykładzie funkcji `powierzchnia()`, która oblicza powierzchnię prostokąta na podstawie macierzy zawierającej współrzędne jego wierzchołków.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npowierzchnia = function(x){\n  a = x[1, 2] - x[1, 1]\n  b = x[2, 2] - x[2, 1]\n  a * b\n}\n```\n:::\n\n\n\n\n\n\nJednym z możliwych narzędzi do testów jednostkowych w R jest pakiet **testthat** [@R-testthat].\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(testthat)\n```\n:::\n\n\n\n\n\n\nZawiera on szereg funkcji sprawdzających czy działanie naszych funkcji jest zgodne z oczekiwaniem.\nFunkcje w tym pakiecie rozpoczynają się od prefiksu `expect_` (oczekuj).\n\nW przypadku funkcji `powierzchnia()` oczekujemy, że wynik będzie zawierał tylko jeden element.\nMożemy to sprawdzić za pomocą funkcji `expect_length()`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnowy_p = matrix(c(0, 0, 6, 5), ncol = 2)\nexpect_length(powierzchnia(nowy_p), 1)\n```\n:::\n\n\n\n\n\n\nJeżeli wynik ma długość jeden to wówczas nic się nie stane.\nW przeciwnym razie pojawi się komunikat błędu.\n\nWiemy, że powierzchnia naszego przykładowego obiektu `nowy_p` to 30.\nDo sprawdzenia, czy nasza funkcja daje na tym obiekcie dokładnie taki wynik możemy użyć `expect_equal()`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpect_equal(powierzchnia(nowy_p), 30)\n```\n:::\n\n\n\n\n\n\nW momencie, gdy wynik jest zgodny to nie nastąpi żadna reakcja, a w przeciwnym razie wystąpi błąd.\nW pakiecie **testthat** istnieją inne funkcje podobne do `expect_equal()`.\nPrzykładowo, funkcja `expect_identical()` sprawdza nie tylko podobieństwo wartości, ale też to czy klasa wyników jest taka sama.\n\nAby sprawdzić czy nasza funkcja na pewno zwróci błąd w przypadku podania niepoprawnych danych wejściowych możemy użyć funkcji `expect_error()`.\nJej działanie jest przedstawione poniżej.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpect_error(powierzchnia(3, 5, 2, \"a\"))\nexpect_error(powierzchnia(matrix(c(0, 0, 6, 5), ncol = 2)))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: `powierzchnia(matrix(c(0, 0, 6, 5), ncol = 2))` did not throw an error.\n```\n\n\n:::\n:::\n\n\n\n\n\n\nW przypadku, gdy wywołanie funkcji zwróci błąd, `expect_error()` nic nie zwróci.\nNatomiast, jeżeli wywołania funkcji nie zwróci błędu, `expect_error()` zatrzyma swoje działanie i zwróci komunikat.\nOdpowiednikami `expect_error()` dla ostrzeżeń jest `expect_warning()`, a dla wiadomości `expect_message()`.\n\nPozostałe funkcje z tego pakietu są wymienione i opisane na stronie <https://testthat.r-lib.org/reference/index.html>.\n\n::: {.callout-note appearance=\"simple\"}\n\n## ZADANIA\n\n1. Stwórz nowy plik `temp.R`.\n2. Wewnątrz tego pliku dodaj kilka testów sprawdzających funkcję ze swojego pakietu.\n3. Upewnij się, że wszystkie testy działają poprawnie (nie zwracają błędów).\n\n:::\n\n## Wbudowane testy {#wbudowane-testy}\n\nTesty jednostkowe można również wbudować wewnątrz pakietu - w efekcie, gdy naniesiemy w nim jakieś zmiany możemy sprawdzić czy otrzymujemy takie same wyniki.\n\nPierwszym krokiem do używania wbudowanych testów jest ustawienie odpowiedniej infrastruktury używając funkcji `use_testthat()`. \nPowoduje ona dodanie pakietu **testthat** do wpisu `Suggests:`, stworzenie folderów `tests/` i `tests/testthat/` oraz pliku `tests/testthat.R`.\n\n```r\nuse_testthat()\n#> ✔ Adding 'testthat' to Suggests field in DESCRIPTION\n#> ✔ Creating 'tests/testthat/'\n#> ✔ Writing 'tests/testthat.R'\n```\n\nTeraz możliwe jest napisanie testów jednostkowych.\nZazwyczaj polega to na stworzeniu oddzielnego pliku dla każdej funkcji z naszego pakietu.\nPrzykładowo, nasz pakiet zawiera funkcję `powierzchnia()`, dlatego też do jego testowania możemy stworzyć nowy plik `tests/testthat/test-powierzchnia.R`.\nWewnątrz tego pliku należy sprawdzać kolejne aspekty działania kodu używając funkcji `test_that()`, gdzie należy podać (1) opis tego co jest sprawdzane i (2) testy wewnątrz nawiasów klamrowych.\nPrzykładowy plik `tests/testthat/test-powierzchnia.R` może wyglądać w ten sposób:\n\n```r\nnowy_p = matrix(c(0, 0, 6, 5), ncol = 2)\n\ntest_that(\"struktura wyniku jest poprawna\", {\n  expect_length(powierzchnia(nowy_p), 1)\n})\n\ntest_that(\"wartosc wyniku jest poprawna\", {\n  expect_equal(powierzchnia(nowy_p), 30)\n})\n\ntest_that(\"wystepuja odpowiednie bledy\", {\n  expect_error(powierzchnia(3, 5, 2, \"a\"))\n})\n```\n\nPo napisaniu testów można sprawdzić czy wszystkie z nich dają odpowiedni wynik używając `devtools::test()`^[Testy są też automatycznie uruchamiane podczas sprawdzania pakietu].\nW efekcie wyświetlone zostaną wszystkie testy i zostanie wskazane, które z nich się nie powiodły i należy je poprawić.\n\n## Pokrycie kodu testami jednostkowymi\n\nW przypadku testów jednostkowych możliwe jest sprawdzenie pokrycia kodu testami.\nPokrycie kodu to procent kodu, który jest wykonywany podczas uruchamiania testów.\nW przypadku, gdy pokrycie kodu jest niskie, oznacza to, że testy nie sprawdzają wszystkich możliwych przypadków działania funkcji.\nInaczej mówiąc, może to oznaczać, że pewne części kodu nie są testowane i mogą zawierać błędy lub działać niepoprawnie.\n\nPokrycie kodu testami można sprawdzić lokalnie używając funkcji `devtools::test_coverage()` lub też można użyć systemu CI/CD (o tym później), żeby sprawdzić pokrycie testami na zewnętrznym serwerze.\n\n\n::: {.callout-note appearance=\"simple\"}\n\n## ZADANIA\n\n1. Przenieś testy z pliku `temp.R` do odpowiedniego pliku wewnątrz folderu `tests/testthat/`.\n2. Usuń plik `temp.R`.\n3. Uruchom testy używając `devtools::test()`.\nCzy wszystkie z nich działają poprawnie?\n4. Spróbuj użyć danych wbudowanych w pakiet do testów.\n5. Uruchom `devtools::test_coverage()` i sprawdź pokrycie kodu testami.\n\n:::\n\n## Strona internetowa pakietu\n\nDodatkowo w R istnieje możliwość prostego stworzenia stron internetowych dla wybranego pakietu używając pakietu **pkgdown** [@R-pkgdown]. \nPrzykład takiej strony można zobaczyć pod adresem <https://pkgdown.r-lib.org/index.html>.\n\nStworzenie strony pakietu wymaga jedynie wywołania funkcji `usethis::use_pkgdown()` oraz `pkgdown::build_site()` wewnątrz pakietu R.\nW efekcie działania tych funkcji zostanie utworzony folder `docs/` zawierający stronę internetową reprezentującą pakiet i jego dokumentację. \nW przypadku, gdy pakiet znajduje się na GitHubie możliwe jest wyświetlenie tej strony pod adresem `https://<nazwauzytkownika>.github.io/<nazwapakietu>/`.\nAby ta strona była dostępna w internecie należy na platformie GitHub wejść w zakładkę Settings, następnie znaleźć część określoną jako Pages, i określić Source jako \"main branch /docs folder\".\n\nAlternatywą dla powyższej funkcji jest `usethis::use_pkgdown_github_pages()`.\nWykonuje ona więcej kroków automatycznie: tworzy nową gałąź Git oraz dodaje nowy plik konfiguracji GitHub Action (więcej o tym w kolejnej sekcji), który będzie starał się automatycznie budować stronę internetową pakietu w chmurze po każdej zmianie w kodzie.\n\n<!-- podsumowanie podstawowych narzedzi budowania pakietow R -->\n\n## CI/CD\n\nCiągła integracja i wdrażanie (ang. *continuous integration and deployment*, CI/CD) to podejście do tworzenia oprogramowania, które polega na łączeniu zmian w kodzie, a następnie automatycznym testowaniu tych zmian.\nJest to szerokie podejście, które może być realizowane na wiele sposobów.\n\nTutaj skupimy się na paru przykładach CI/CD powiązanych z pracą nad pakietami R.\nTen temat jest również mocno powiązany z kontrolą wersji oraz platformami do hostowania kodu, takimi jak GitHub, GitLab, czy Bitbucket.\n\nPlatforma GitHub oferuje CI/CD poprzez system o nazwie [GitHub Actions](https://docs.github.com/en/actions).\nPrzykłady działania GitHub Actions można znaleźć w zakładce Actions na stronie każdego repozytorium.\nW dużym skrócie, GitHub Actions pozwala na uruchamianie kodu w chmurze po przesłaniu zmiany w kodzie na platformę GitHub.^[Możliwe jest też uruchamianie kodu co zadany czas.]\nNajprościej można wyobrazić sobie ten proces jako przesłanie kodu na chmurę należącą do GitHuba, gdzie zostaje on uruchomiony i przetestowany.^[Należy pamiętać, że GitHub Actions nie jest w pełni darmowy.]\n\nW przypadku pakietów R, GitHub Actions może być używany do automatycznego budowania i sprawdzania pakietu (na różnych systemach operacyjnych), wykonywania testów jednostkowych, sprawdzania pokrycia kodu testami, oraz do automatycznego budowania strony internetowej pakietu.\nSamo używanie GitHub Actions jest możliwe poprzez dodanie pliku konfiguracyjnego do repozytorium.\nTaki plik (lub pliki) musi znajdować się w folderze `.github/workflows/` i mieć rozszerzenie `.yaml`.\n\nPrzykładowy plik konfiguracyjny dla GitHub Actions może wyglądać w ten sposób:\n\n```yaml\non:\n  push:\n    branches: [main]\n\nname: R-CMD-check\n\njobs:\n  R-CMD-check:\n    runs-on: ubuntu-latest\n\n    name: ubuntu-latest release\n\n    env:\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n      R_KEEP_PKG_SOURCE: yes\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: r-lib/actions/setup-pandoc@v2\n\n      - uses: r-lib/actions/setup-r@v2\n        with:\n          r-version: release\n          http-user-agent: ubuntu-latest\n          use-public-rspm: true\n\n      - uses: r-lib/actions/setup-r-dependencies@v2\n        with:\n          extra-packages: any::rcmdcheck\n          needs: check\n\n      - uses: r-lib/actions/check-r-package@v2\n        with:\n          upload-snapshots: true\n```\n\nDodania pliku konfiguracyjnego można wykonać ręcznie lub przy pomocy funkcji `usethis::use_github_action()`, która pozwala na wybranie jednego z kilku szablonów.\nWarto zacząć od wyboru jednego z szablonów i dostosowania go do własnych potrzeb.\n\nPowyższy plik konfiguracyjny ma na celu sprawdzenie pakietu na systemie Ubuntu.\nMożliwe jest także użycie systemu GitHub Actions do, np. określenia pokrycia kodu testami czy też automatycznego budowania strony internetowej pakietu.\nPrzykłady różnych plików konfiguracyjnych związanych z pakietami R można znaleźć w repozytorium <https://github.com/r-lib/actions/tree/v2/examples>. \nW kontekście tworzenia pakietów R związanych z danymi przestrzennymi, warto sprawdzić pliki konfiguracyjne GitHub Actions już istniejących pakietów R opartych o biblioteki GDAL czy PROJ.\n\n<!-- styler, lintr -->\n\n::: {.callout-note appearance=\"simple\"}\n\n## ZADANIA\n\n1. Dodaj do swojego pakietu plik konfiguracyjny dla GitHub Actions, który będzie sprawdzał pakiet na systemie Ubuntu.\n2. Prześlij zmiany na GitHuba i sprawdź czy GitHub Actions działa poprawnie.\n3. Dodaj do swojego pakietu plik konfiguracyjny dla GitHub Actions, który będzie sprawdzał pokrycie kodu testami. \nMożesz to zrobić albo rozszerzając plik konfiguracyjny z poprzedniego zadania, albo tworząc nowy plik konfiguracyjny.\n4. Prześlij zmiany na GitHuba i sprawdź czy GitHub Actions działa poprawnie.\n5. Dodaj do swojego pakietu plik konfiguracyjny dla GitHub Actions, który będzie budował stronę internetową pakietu.\nMożesz to zrobić albo rozszerzając plik konfiguracyjny z poprzedniego zadania, albo tworząc nowy plik konfiguracyjny.\n6. Prześlij zmiany na GitHuba i sprawdź czy GitHub Actions działa poprawnie oraz czy strona internetowa pakietu istnieje.\n7. W przypadku, gdy wszystko działa poprawnie, dodaj dwie nowe linie do pliku `DESCRIPTION` zawierające linki do strony internetowej pakietu oraz do repozytorium pakietu:\n\n```r\nURL: https://ja.github.io/mojpakiet/\nBugReports: https://github.com/ja/mojpakiet/issues\n```\n\n:::\n\n## CRAN\n\nCRAN (*Comprehensive R Archive Network*) to repozytorium zawierające pakiety R.\nWszystkie pakiety znajdujące się w tym repozytorium są sprawdzane pod kątem zgodności z wymaganiami na kilku systemach operacyjnych.\nWymagania można znaleźć pod adresami <https://cran.r-project.org/web/packages/policies.html> oraz <https://cran.r-project.org/web/packages/submission_checklist.html>.\nCo ważne, wymagania te zmieniają się w czasie.^[Niektóre zasady działania CRAN są krytykowane, co można przeczytać pod adresem <https://github.com/cranchange/cran_change.org>.]\n\n::: {.callout-note}\nTworzenie nowych narzędzi daje często satysfakcję. \nNależy jednak pamiętać, że narzędzia komputerowe są zależne od innych narzędzi, które mogą się zmieniać w czasie.\nW związku z tym, narzędzia komputerowe wymagają stałej uwagi oraz konserwacji (ang. *maintenance*).\n:::\n\nPodejście stosowane przez CRAN kładzie odpowiedzialność za poprawność działania pakietu na jego autorach.\nW zamian, potencjalni użytkownicy mogą mieć pewność, że pakiet jest zgodny z wymaganiami CRAN, działa poprawnie i jest możliwy do zainstalowania na różnych systemach operacyjnych.\nDodatkowo, CRAN tworzy wersje binarne pakietów dla systemów Windows i Mac OS, co znacznie ułatwia i przyspiesza ich instalację.\n\n::: {.callout-note}\nWcześniej przedstawiona funkcja `devtools::check()` sprawdza pakiet pod kątem różnych testów, ale nie sprawdza czy jest on w pełni zgodny z wymaganiami CRAN.\nWynika to z kilku kwestii. \nTrzy najważniejsze to:\n1. Niektóre z wymagań są sprawdzane manualnie przez CRAN team.\n2. Niektóre z wymagań nie są w pełni znane.\n3. CRAN sprawdza pakiety na różnych systemach operacyjnych, a `devtools::check()` sprawdza pakiet tylko na systemie, na którym jest uruchomiony.\n:::\n\nW momencie gdy uważam, że pakiet jest w wersji stabilnej i gotowy do wysłania na CRAN, wykonuję następujące kroki:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1 dodaję dokumentację\ndevtools::document()\n# 2 testuję pakiet\ndevtools::check()\n# 3 sprawdzam czy pakiet jest zgodny z wymaganiami CRAN\nrcmdcheck::rcmdcheck(args = c(\"--no-manual\", \"--as-cran\"))\n# 4 sprawdzam czy wszystkie linki w dokumentacji działają\n# install.packages(\"urlchecker\", repos = \"https://r-lib.r-universe.dev\")\nurlchecker::url_check()\nurlchecker::url_update()\n# 5 aktualizuję NEWS i wersję pakietu\n# 6 wysyłam pakiet do CRAN\ndevtools::submit_cran()\n```\n:::\n\n\n\n\n\n\nBardziej złożone (i kompletne) podejście do przygotowania pakietu do CRAN jest opisane na stronie <https://github.com/ThinkR-open/prepare-for-cran>. \n<!-- use_release_issue -->\n\nPo wywołaniu ostatniej z funkcji należy potwierdzić swój adres email, a następnie kliknąć w otrzymany mailowo link.\nW efekcie pakiet zostanie wysłany do CRAN, gdzie zostanie sprawdzony przez automatyczne narzędzia.\n\nW przypadku wysłania pakietu do CRAN po raz pierwszy, jest on sprawdzony manualnie przez jedną z osób w tzw. CRAN team.\nTaka osoba może albo zaakceptować pakiet, albo poprosić o poprawienie błędów i przesłanie pakietu ponownie.\n\nAktualizowanie pakietu przebiega w ten sam sposób -- poprzez wywołanie `devtools::submit_cran()`.^[Możliwe jest też wysłanie pakietu do CRAN za pomocą strony <https://cran.r-project.org/submit.html>.]\nWtedy pakiet zostanie sprawdzony przez automatyczne narzędzia.\nW przypadku, gdy automatyczne testy zwrócą jakieś problemy (ostrzeżenia lub notatki), zostanie on również obejrzany przez CRAN team.\nWarto pamiętać, że nie należy aktualizować wersji CRAN pakietu częściej niż raz na miesiąc.\n\n<!-- revdeps -->\n\n::: {.callout-note}\nMożliwe jest sprawdzenie statusu pakietu przesłanego na CRAN na stronie <https://r-hub.github.io/cransays/articles/dashboard.html>.\n:::\n\nGdy pakiet jest już na CRAN, ale nie jest zgodny z nowymi wymaganiami, otrzyma się prośbę o jego naprawę, a w przypadku nie naniesienie poprawek, zostanie on usunięty z CRAN (*archived*).\n\n::: {.callout-note}\nWysyłanie pakietu na CRAN nie jest jedynym sposobem na jego udostępnienie.\nW różnych sytuacjach możliwe jest też udostępnienie pakietu na innych repozytoriach, np. na GitHubie, GitLabie, Bitbucket, lub na własnym serwerze.\nInne możliwości to np. użycie systemu [**drat**](https://github.com/eddelbuettel/drat) lub [r-universe](https://r-universe.dev/).\nPowyższe rozwiązania nie mają takich samych wymagań jak CRAN, ale wymagają więcej od potencjalnego użytkownika.\nDodatkowo, [bioconductor](https://www.bioconductor.org/) to repozytorium zawierające pakiety R związane z bioinformatyką.\n:::\n",
    "supporting": [
      "pakiety3_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}