{
  "hash": "c9c4546fe464d0ac7b723a6d19f812f5",
  "result": {
    "engine": "knitr",
    "markdown": "# Tworzenie pakietów R (4)\n\n## Zaawansowane dokumentowanie funkcji\n\nSekcje [-@sec-opis-pakietu] oraz [-@sec-metadane-pakietu] omawiały plik `DESCRIPTION` oraz jego zawartość.\nJedną z kwestii, która nie została tam poruszona jest dodanie do pakietu możliwości dokumentowania funkcji [używając języka Markdown](https://roxygen2.r-lib.org/articles/markdown.html).\n<!-- why? -->\nW tym celu należy w pliku `DESCRIPTION` dodać linię `Roxygen: list(markdown = TRUE)`.\n\n```yaml\nPackage: mojpakiet\nTitle: Moje Funkcje Robiace Wszystko\nVersion: 0.0.1\nAuthors@R: \n    person(given = \"Imie\",\n           family = \"Nazwisko\",\n           role = c(\"cre\", \"aut\"),\n           email = \"imie.nazwisko@example.com\")\nDescription: Tworzenie, przeliczanie i wyliczanie wszystkiego. \n    Czasami nawet więcej.\nLicense: CC0\nEncoding: UTF-8\nLazyData: true\nRoxygenNote: 7.2.3\nRoxygen: list(markdown = TRUE)\n```\n\nTeraz możliwe jest stosowanie znaczników Markdown w dokumentacji funkcji.\nPoniżej pokażę ich użycie oraz inne, wcześniej nie omówione, możliwości pakietu **roxygen2** (@sec-dok-fun1).\n\n<!-- test this doc!! -->\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Konwersja odleglosci\n#'\n#' @description Funkcja sluzaca do konwersji odleglosci z mil na kilometry\n#'\n#' @param mil wektor zawierajacy wartosci odleglosci w milach\n#' \n#' @details Funkcja `konwersja_odl()` konwertuje odleglosci z \n#'     [mil](https://en.wikipedia.org/wiki/Mile) na kilometry używając wzoru\n#'     przelicznika: 1 mila = 1.609344 km\n#' \n#' Ta funkcja jest:\n#' * Niezwykle przydatna\n#' * Bardzo prosta\n#'\n#' @return wektor numeryczny\n#' @export\n#' \n#' @references Tobler, W. R. (1970). \"A Computer Movie Simulating Urban Growth \n#'     in the Detroit Region\". Economic Geography. 46: 234–240\n#' \n#' @seealso [konwersja_temp()], [units::set_units()]\n#'\n#' @examples\n#' konwersja_odl(75)\n#' konwersja_odl(110)\n#' konwersja_odl(0)\n#' \\dontrun{\n#' konwersja_odl(c(0, 75, 110))\n#' }\nkonwersja_odl = function(mil){\n    mil * 1.609344\n}\n```\n:::\n\n\n\n\n\n\nJęzyk Markdown ma kilka zastosowań w dokumentacji funkcji.\nPo pierwsze pozwala na stylizowanie tekstu, np. pogrubienie, pochylenie, itp.\nPrzykładowo, \n\n``` markdown\n`konwersja_odl()` \n```\n\nzamieni się w `konwersja_odl()`.\nPo drugie, Markdown pozwala na dodanie linków do innych stron internetowych, które mogą być przydatne w kontekście funkcji.\nUżywa się wtedy składni `[mil](https://en.wikipedia.org/wiki/Mile)`, gdzie `mil` to tekst, który będzie wyświetlany, a `https://en.wikipedia.org/wiki/Mile` to link do strony internetowej.\n\nMarkdown pozwala również na odnoszenie się do dokumentacji innych funkcji, zarówno wewnątrz pakietu, jak i zewnętrznych.\nWewnętrzne funkcje odwołuje się za pomocą `[konwersja_temp()]`, gdzie `konwersja_temp()` to nazwa funkcji, do której chcemy się odwołać, a zewnętrzne za pomocą `[units::set_units()]`, gdzie `set_units()` to nazwa funkcji, do której chcemy się odwołać, a `units` to nazwa pakietu, w którym ta funkcja się znajduje.\nKolejną możliwością jest proste wstawianie list używając znacznika `*`.^[Markdown umożliwia także inne kwestie, takie jak wstawianie obrazków, tabel, itp.]\n\nDokumentacja funkcji może zawierać także inne znaczniki, które nie zostały omówione w poprzednich sekcjach.\nObejmuje to takie znaczniki jak:\n\n- `@details`: dodatkowe informacje o funkcji, w tym jej zastosowanie, ograniczenia, specjalne przypadki, itp.\n- `@seealso`: odnośniki do innych funkcji, które mogą być podobne lub powiązane z funkcją, której dokumentacja jest tworzona\n- `@references`: odnośniki do literatury (np. artykułu naukowego), na podstawie której powstała funkcja\n\nZnacznik `@examples` pozwala na dodanie przykładów użycia funkcji.\nCzęść z tych przykładów można powstrzymać przed uruchomieniem używając znacznika `\\dontrun{}`.\nMoże się to przydać w kwestii, np. gdy chcemy pokazać przykład wystąpienia błędu. \n\nWięcej informacji na temat dokumentowania funkcji można znaleźć na stronie <https://r-pkgs.org/man.html#roxygen2-basics>.\n\n## Dodatkowe możliwości pakietu **usethis**\n\nPakiet **usethis** także oferuje inne możliwości, które nie zostały omówione w poprzednich sekcjach.\nNie są one niezbędne do tworzenia pakietów, ale mogą być przydatne w niektórych przypadkach.\nTutaj pokrótce omówię kilka z nich:\n\n- `use_citation()`: dodaje [plik `inst/CITATION`](https://r-pkgs.org/misc.html#sec-misc-inst-citation) do pakietu, który zawiera informacje w jaki sposób cytować dany pakiet. \nZazwyczaj warto dodać ten plik, gdy dany pakiet powiązany jest z publikacją naukową.\n- `use_package_doc()`: tworzy on plik `R/{nazwapakietu}-package.R`, który jest ogólną dokumentacją pakietu.\nMożna go później wywołać poprzez `?{nazwapakietu}`.\n- `use_cran_badge()`: dodaje plakietkę (ang. *badge*) z odnośnikiem do strony pakietu na CRAN do pliku README.\nMożliwe jest także dodanie innych plakietek używając funkcji `use_badge()`, w której należy podać nazwę i odnośnik do plakietki.^[Polecam obejrzeć repozytoria GitHub innych pakietów po inspiracje.]\n\nDodatkowo, pakiet **usethis** pozwala na dodawanie informacji do pakietu z poziomu R, np. przy użyciu funkcji `use_author()` czy `use_version()`.\n\n::: {.callout-note appearance=\"simple\"}\n\n## ZADANIA\n\n1. Dodaj do swojego pakietu możliwość dokumentowania funkcji używając Markdown.\n2. Dodaj do jednej z funkcji dodatkowe informacje używając znaczników Markdown: odnośniki do innych funkcji, odnośniki do literatury, listę, itp.\n3. Dodaj do swojego pakietu plik `inst/CITATION` używając funkcji `use_citation()`.\n4. Dodaj do swojego pakietu plik `R/{nazwapakietu}-package.R` używając funkcji `use_package_doc()`.\n5. Dodaj do swojego pakietu plakietkę z odnośnikiem do strony pakietu na CRAN używając funkcji `use_cran_badge()`.\n6. Zaktualizuj dokumentację używając funkcji `devtools::document()`, a następnie załaduj pakiet używając funkcji `devtools::load_all()`.\nSprawdź jakie zaszły zmiany w dokumentacji.\n7. Prześlij wszystkie zmiany do repozytorium zdalnego na GitHubie.\n\n:::\n\n## Inne kwestie związane z tworzeniem pakietów R\n\nDo tej pory omówiliśmy najważniejsze kwestie związane z tworzeniem pakietów R.\nJednakże, istnieje wiele innych aspektów, które nie zostały tutaj poruszone, ale warto zdawać sobie z nich sprawę.\n\nJednym z nich jest plik `NAMESPACE`, który jest generowany automatycznie przez pakiet **roxygen2**.\nPlik ten zawiera informacje o funkcjach, które są eksportowane z pakietu, a także o funkcjach, które są importowane z innych pakietów.\nTego pliku nie należy edytować ręcznie.\n\nInnym aspektem jest plik `.Rbuildignore`, który zawiera informacje o plikach, które mają być ignorowane podczas budowania pakietu.\nWarto dodać do tego pliku pliki, które nie są niezbędne do działania pakietu, ale są powiązane z jego tworzeniem. \nPrzykładowo, obejmuje to plik projektu RStudio `^{nazwapakietu}.Rproj$`, pliki czt folder związane z CI/CD (np. `^\\.github$`), czy folder z surowymi danymi i kodem (np. `^data-raw$`).\n\nKolejnym aspektem są zależności pakietów (ang. *dependencies*).\nZ jednej strony, nasz pakiet może wymagać innych pakietów do działania, a z drugiej natomiast, nasz pakiet może być wymagany przez inne pakiety.\nObie te kwestie są złożone i decyzje o nich mają różne konsekwencje.\n\nW przypadku zależności naszego pakietu od innych pakietów, możemy określić je w pliku `DESCRIPTION` w sekcji `Imports` lub `Suggests`.\nW efekcie, nasz pakiet staje się zależny od innych pakietów, które są wymienione w tych sekcjach.\nZmiany w tych pakietach (i ich zależnościach) mogą mieć wpływ na nasz pakiet.\nPełne drzewo zależności pakietu można wyświetlić używając funkcji `pak::pkg_deps_tree()`.\n\nIstnieją różne podejścia do określania tego jakie pakiety powinny być wymagane przez nasz pakiet.\nJednym z podejść jest używanie minimalnej liczby zależności, inne natomiast obejmuje stosowanie zależności co do autorów których mamy zaufanie.\nJakiekolwiek założenie jest przyjęte, nie warto przesadzać z liczbą zależności, gdyż może to mieć negatywny wpływ na czas budowania pakietu, a także na jago stabilność.\n\nNasz pakiet R może być również wymagany przez inne pakiety---taka sytuacja nazywana jest zależnością wsteczną (ang. *reverse dependency*).\nW tym przypadku, zmiany w naszym pakiecie mogą mieć wpływ na inne pakiety.\nChcemy, aby wprowadzane przez nas zmiany nie powodowały szerokich konsekwencji w innych pakietach.\nWykonanie sprawdzenia wpływu zmian na zależności wsteczne może być wykonane używając funkcji `usethis::use_revdep()`.\n\n## Dodatkowe materiały\n\nW celu poznania i zrozumienia złożonych aspektów tworzenia pakietów R cennymi źródłami wiedzy może być książki [R packages](https://r-pkgs.org) [@wickham2015r] oraz [rOpenSci Packages: Development, Maintenance, and Peer Review](https://ropensci.github.io/dev_guide/) [@ropensci_2019_2554759].\nDodatkowo, w niektórych przypadkach pomocna może być oficjalna dokumentacja [Writing R Extensions](https://cran.r-project.org/doc/manuals/R-exts.html#Creating-R-packages) [@team1999writing].\nNiezastąpione jest także czytanie kodu źródłowego innych pakietów R na GitHubie.\n",
    "supporting": [
      "pakiety4_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}